/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Author: ElOsitoAzul (https://sketchfab.com/ElOsitoAzul)
License: CC-BY-4.0 (http://creativecommons.org/licenses/by/4.0/)
Source: https://sketchfab.com/3d-models/hand-with-a-bouquet-of-flowers-mano-low-poly-f38e4171756c4b48acac3bd339ead876
Title: Hand with a bouquet of flowers / mano low poly
*/

import { FunctionComponent, useMemo, useRef, useState } from "react";
import { Outlines, useCursor, useGLTF } from "@react-three/drei";
import { GLTF } from "three-stdlib";
import { useFrame } from "@react-three/fiber";
import { Group, Vector3 } from "three";

const path = "/flowers/scene.gltf";

type GLTFResult = GLTF & {
  nodes: {
    Object_4: THREE.Mesh;
    Object_9: THREE.SkinnedMesh;
    Object_33: THREE.Mesh;
    Object_35: THREE.Mesh;
    Object_37: THREE.Mesh;
    Object_39: THREE.Mesh;
    Object_41: THREE.Mesh;
    Object_43: THREE.Mesh;
    Object_45: THREE.Mesh;
    Object_47: THREE.Mesh;
    Object_49: THREE.Mesh;
    GLTF_created_0_rootJoint: THREE.Bone;
  };
  materials: {
    JACKET: THREE.MeshPhysicalMaterial;
    Material: THREE.MeshPhysicalMaterial;
    ["Material.001"]: THREE.MeshPhysicalMaterial;
    ["Material.002"]: THREE.MeshStandardMaterial;
    ["Material.003"]: THREE.MeshStandardMaterial;
  };
};

export const Flower: FunctionComponent<{
  position?: Vector3;
  rotation?: [number, number, number];
  isClickable: boolean;
  onClick?: () => void;
}> = ({ position, rotation, onClick, isClickable }) => {
  const { dir, angularSpeed } = useMemo(() => {
    return {
      dir: Math.random() < 0.5 ? -1 : 1,
      angularSpeed: Math.max(Math.min(Math.random(), 0.1), 0.5),
    };
  }, []);

  const [onHover, setOnHover] = useState(false);

  const flowerRef = useRef<Group>(null);
  const { nodes, materials } = useGLTF(path) as GLTFResult;

  useFrame((_, delta) => {
    if (flowerRef.current) {
      flowerRef.current.rotation.z += delta * dir * angularSpeed;

      if (onHover) {
        const scaleFactor = Math.min(
          1.5,
          flowerRef.current.scale.x + delta * 2,
        );
        flowerRef.current.scale.set(scaleFactor, scaleFactor, scaleFactor);
      } else {
        const scaleFactor = Math.max(1, flowerRef.current.scale.x - delta * 2);
        flowerRef.current.scale.set(scaleFactor, scaleFactor, scaleFactor);
      }
    }
  });

  useCursor(onHover && isClickable, "pointer");

  return (
    <group position={position} rotation={rotation} ref={flowerRef}>
      <group rotation={[(Math.PI / 180) * 75, 0, (Math.PI / 180) * 10]}>
        <group
          position={[0.631, -2.297, 0.303]}
          visible={true}
          onClick={() => {
            if (isClickable) {
              onClick?.();
              setOnHover(false);
            }
          }}
          onPointerEnter={() => isClickable && setOnHover(true)}
          onPointerLeave={() => isClickable && setOnHover(false)}
        >
          <mesh
            castShadow
            receiveShadow
            geometry={nodes.Object_33.geometry}
            material={materials["Material.001"]}
            position={[-0.716, 2.578, -0.186]}
            rotation={[-1.876, -1.165, -2.189]}
            scale={0.048}
          >
            {onHover && isClickable && (
              <Outlines thickness={5} color="#50C878" />
            )}
          </mesh>
          <mesh
            castShadow
            receiveShadow
            geometry={nodes.Object_35.geometry}
            material={materials["Material.002"]}
            position={[-0.665, 2.544, -0.158]}
            rotation={[-1.973, -1.134, -2.278]}
            scale={[0.067, 0.089, 0.067]}
          />
        </group>
      </group>
    </group>
  );
};

useGLTF.preload(path);
